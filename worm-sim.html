<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ToonyTime Platformer — Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; background:#0b1020; color:#eaeef6; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    #gameContainer { width:100%; height:100vh; display:flex; align-items:center; justify-content:center; }
    canvas { image-rendering: pixelated; }
    .note {
      position:fixed; left:12px; bottom:10px; font-size:13px; opacity:.8;
      background:linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
      padding:6px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.03);
      backdrop-filter: blur(4px);
    }
  </style>
  <!-- Phaser CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
  <div id="gameContainer"></div>
  <div class="note">Arrows / WASD to move, Z to jump, X to dash, M mute</div>

<script>
/* ============================================================
   ToonyTime Platformer Demo (Phaser 3)
   Single-file HTML. Save as index.html and open in a browser.
   ============================================================ */

const GAME_WIDTH = 960;
const GAME_HEIGHT = 540;

const config = {
  type: Phaser.AUTO,
  parent: 'gameContainer',
  width: GAME_WIDTH,
  height: GAME_HEIGHT,
  backgroundColor: '#0b1220',
  physics: {
    default: 'arcade',
    arcade: {
      gravity: { y: 1200 },
      debug: false
    }
  },
  scene: [BootScene, MenuScene, OverworldScene, LevelScene, UIScene]
};

/* --------------- Boot Scene (tiny loader & create runtime assets) --------------- */
function BootScene() { Phaser.Scene.call(this, { key: 'BootScene' }); }
BootScene.prototype = Object.create(Phaser.Scene.prototype);
BootScene.prototype.constructor = BootScene;
BootScene.prototype.preload = function() {
  // load nothing — create quick-generated assets in create()
};
BootScene.prototype.create = function() {
  // Generate simple sprites using graphics to avoid external assets

  // Player sprite (rounded square)
  {
    const g = this.make.graphics({ x:0, y:0, add: false });
    g.fillStyle(0x58a6ff, 1);
    g.fillRoundedRect(0,0,40,48,8);
    g.fillStyle(0x11334a, 1);
    g.fillRect(10,30,20,6); // simple face-ish
    g.generateTexture('player', 40,48);
    g.destroy();
  }

  // Enemy sprite
  {
    const g = this.make.graphics({ add:false });
    g.fillStyle(0xff7b7b, 1);
    g.fillRoundedRect(0,0,36,34,8);
    g.fillStyle(0x2b0b0b,1);
    g.fillRect(8,22,20,4);
    g.generateTexture('enemy', 36,34);
    g.destroy();
  }

  // Collectible (shiny orb)
  {
    const g = this.make.graphics({ add:false });
    g.fillStyle(0xfff372,1);
    g.fillCircle(12,12,12);
    g.fillStyle(0xffffff,0.5);
    g.fillCircle(8,8,4);
    g.generateTexture('orb', 24,24);
    g.destroy();
  }

  // Platform tile
  {
    const g = this.make.graphics({ add:false });
    g.fillStyle(0x3b5b6e, 1);
    g.fillRect(0,0,64,24);
    g.fillStyle(0x23414f,1);
    g.fillRect(0,0,64,6);
    g.generateTexture('tile', 64,24);
    g.destroy();
  }

  // Background clouds (for parallax)
  {
    const g = this.make.graphics({ add:false });
    g.fillStyle(0xffffff, 0.12);
    g.fillEllipse(80,40,160,80);
    g.fillEllipse(20,60,120,60);
    g.generateTexture('cloud', 160,120);
    g.destroy();
  }

  // Particle sparkle
  {
    const g = this.make.graphics({ add:false });
    g.fillStyle(0xffffff, 1);
    g.fillCircle(4,4,4);
    g.generateTexture('spark', 8,8);
    g.destroy();
  }

  // Create minimal SFX using WebAudio oscillator wrappers (made later in UIScene)
  this.scene.start('MenuScene');
};

/* ------------------- Menu Scene ------------------- */
function MenuScene() { Phaser.Scene.call(this, { key: 'MenuScene' }); }
MenuScene.prototype = Object.create(Phaser.Scene.prototype);
MenuScene.prototype.constructor = MenuScene;
MenuScene.prototype.create = function() {
  // Big title
  const title = this.add.text(GAME_WIDTH/2, 120, 'TOONYTIME', { font: '64px "Arial"', fill: '#f0f7ff' }).setOrigin(0.5).setShadow(2,2,'#000',8);

  // Play button
  const playBtn = this.add.container(GAME_WIDTH/2, 240);
  const btnBox = this.add.rectangle(0,0,340,72, 0x4477aa).setStrokeStyle(2,0xffffff,0.08).setInteractive({useHandCursor:true});
  const playText = this.add.text(0,0,'Play — Overworld', { font: '28px Arial', fill:'#fff' }).setOrigin(0.5);
  playBtn.add([btnBox, playText]);

  btnBox.on('pointerdown', ()=> {
    this.cameras.main.flash(200,255,255,255);
    this.scene.start('OverworldScene');
  });

  // Quick Level (skip to level)
  const quickBtn = this.add.container(GAME_WIDTH/2, 340);
  const qBox = this.add.rectangle(0,0,240,52,0x66aa66).setInteractive({useHandCursor:true});
  const qText = this.add.text(0,0,'Quick Level', { font: '20px Arial', fill:'#072' }).setOrigin(0.5);
  quickBtn.add([qBox,qText]);
  qBox.on('pointerdown', ()=> {
    this.scene.start('LevelScene', { level: 1 });
  });

  // Credits small
  this.add.text(GAME_WIDTH - 12, GAME_HEIGHT - 12, 'Demo — no assets • code-only', { font: '12px Arial', fill:'#bcd' }).setOrigin(1,1);

  // Floating particles for vibe
  const emitter = this.add.particles('spark').createEmitter({
    x: { min: 0, max: GAME_WIDTH },
    y: { min: GAME_HEIGHT-120, max: GAME_HEIGHT },
    lifespan: 2200,
    speedY: { min: -60, max: -160 },
    quantity: 1,
    scale: { start: 1, end: 0 },
    frequency: 220
  });

  // Subtle background gradient using graphics
  const bg = this.add.graphics().fillGradientStyle(0x061025,0x0b1628,0x0b1628,0x061025,1).fillRect(0,0,GAME_WIDTH,GAME_HEIGHT);
  bg.setDepth(-2);
  title.setDepth(1);
};

/* ---------------- Overworld Scene (scrolling map level select) ---------------- */
function OverworldScene() { Phaser.Scene.call(this, { key: 'OverworldScene' }); }
OverworldScene.prototype = Object.create(Phaser.Scene.prototype);
OverworldScene.prototype.constructor = OverworldScene;
OverworldScene.prototype.create = function() {
  const width = 2200;
  const height = GAME_HEIGHT;
  this.cameras.main.setBackgroundColor('#081125');

  // Parallax layers: distant mountains and clouds
  for (let i=0;i<6;i++){
    const cloud = this.add.image(150 + i*300, 80 + (i%2)*20, 'cloud');
    cloud.setAlpha(0.12 + 0.02*i);
    cloud.setScale(0.8 + (i%3)*0.2);
    cloud.setScrollFactor(0.3 + (i%2)*0.05);
  }

  // Ground snapshot (map path)
  this.ground = this.add.graphics();
  this.ground.fillStyle(0x123b3f,1);
  this.ground.fillRoundedRect(0, GAME_HEIGHT - 110, width, 110, 20);

  // Create nodes (levels) along an x axis
  this.levelNodes = [];
  const nodeCount = 6;
  for (let i=0;i<nodeCount;i++){
    const x = 120 + i*( (width-240) / (nodeCount-1) );
    const y = GAME_HEIGHT - 170 - Math.sin(i*1.2)*60;
    const node = this.add.circle(x,y,26,0x7ad6ff).setStrokeStyle(3,0xffffff,0.12).setInteractive({useHandCursor:true});
    const label = this.add.text(x,y+46, `Level ${i+1}`, { font: '18px Arial', fill:'#dff' }).setOrigin(0.5);
    node.levelIndex = i+1;
    node.on('pointerdown', ()=> {
      this.cameras.main.shake(120,0.003);
      this.scene.start('LevelScene', { level: node.levelIndex, startX: 120 + (node.levelIndex-1)*250 });
    });
    this.levelNodes.push(node);
  }

  // Moving "player" icon that can be dragged to pan
  this.cursor = this.add.triangle(0,0, 0,32, 12,0, 24,32, 0x8effa2).setScale(0.9).setDepth(10);
  this.cursor.x = this.levelNodes[0].x;
  this.cursor.y = this.levelNodes[0].y - 60;

  // Camera settings
  this.cameras.main.setBounds(0,0,width,height);
  this.physics.world.setBounds(0,0,width,height);
  this.cameras.main.startFollow(this.cursor, true, 0.08, 0.08);

  // Allow arrow keys or dragging to move cursor
  this.keys = this.input.keyboard.addKeys({ left: Phaser.Input.Keyboard.KeyCodes.LEFT, right: Phaser.Input.Keyboard.KeyCodes.RIGHT });
  this.input.on('pointerdown', (p)=> { this.dragging = true; this.lastPointerX = p.x; });
  this.input.on('pointerup', ()=> { this.dragging = false; });

  // subtle floating characters
  this.tweens.add({
    targets: this.cursor,
    y: `-=${18}`,
    duration: 1200,
    yoyo: true,
    repeat: -1,
    ease: 'Sine.easeInOut'
  });
  // hint text
  this.add.text(18,18,'Overworld — select a level', { font: '18px Arial', fill:'#dff' }).setScrollFactor(0);
};

/* update for overworld */
OverworldScene.prototype.update = function(time, dt) {
  // dragging pan
  if (this.dragging && this.input.activePointer.isDown) {
    const p = this.input.activePointer;
    const dx = (this.lastPointerX - p.x);
    this.lastPointerX = p.x;
    this.cursor.x += dx;
    // clamp
    this.cursor.x = Phaser.Math.Clamp(this.cursor.x, 40, 2100);
  } else {
    // keyboard nudges
    if (this.keys.left.isDown) this.cursor.x -= 4;
    if (this.keys.right.isDown) this.cursor.x += 4;
  }

  // snap cursor vertically near nearest node
  let nearest = this.levelNodes.reduce((acc, n) => {
    const d = Math.abs(n.x - this.cursor.x);
    return d < acc.d ? { node: n, d } : acc;
  }, { node: null, d: 99999 }).node;
  if (nearest) {
    this.cursor.y = Phaser.Math.Linear(this.cursor.y, nearest.y - 60, 0.06);
  }
};

/* ---------------- Level Scene (actual platformer) ---------------- */
function LevelScene() { Phaser.Scene.call(this, { key: 'LevelScene' }); }
LevelScene.prototype = Object.create(Phaser.Scene.prototype);
LevelScene.prototype.constructor = LevelScene;

LevelScene.prototype.init = function(data) {
  this.levelIndex = data.level || 1;
  this.startX = data.startX || 120;
};

LevelScene.prototype.create = function() {
  // camera boundaries for a longer level
  const levelWidth = 3200;
  const levelHeight = GAME_HEIGHT;
  this.cameras.main.setBounds(0,0,levelWidth,levelHeight);
  this.physics.world.setBounds(0,0,levelWidth,levelHeight);

  // Background parallax layers
  const sky = this.add.rectangle(0,0, levelWidth, levelHeight, 0x09203f).setOrigin(0).setScrollFactor(0);
  const mountains = this.add.tileSprite(0, GAME_HEIGHT - 260, levelWidth, 200, 'cloud').setOrigin(0).setAlpha(0.08).setScrollFactor(0.2);
  const cloudLayer = this.add.tileSprite(0,80,levelWidth,120,'cloud').setOrigin(0).setAlpha(0.14).setScrollFactor(0.4);
  const farClouds = this.add.tileSprite(0,40,levelWidth,120,'cloud').setOrigin(0).setAlpha(0.09).setScrollFactor(0.2);

  // Create ground platforms group (static)
  const platforms = this.physics.add.staticGroup();
  // create many platform pieces to form a level
  for (let i=0;i<80;i++){
    const x = i * 120;
    let y = GAME_HEIGHT - 64;
    // random heights to create stairs/gaps
    if (i%7 === 3) y -= 120;
    if (i%11 === 7) y -= 200;
    platforms.create(x, y, 'tile').setOrigin(0,0).refreshBody();
  }
  // add some floating platforms
  for (let i=0;i<18;i++){
    const x = 300 + i*160;
    const y = GAME_HEIGHT - 220 - ((i%4)*35);
    const p = platforms.create(x,y,'tile').setOrigin(0,0).refreshBody();
    // tiny bounce tween for life
    this.tweens.add({ targets: p, y: p.y+6, yoyo:true, repeat:-1, duration:2000 + (i*30) });
  }

  // Player
  this.player = this.physics.add.sprite(this.startX, GAME_HEIGHT - 200, 'player').setScale(1).setCollideWorldBounds(true);
  this.player.body.setSize(30,44).setOffset(5,2);
  this.player.setDepth(5);
  this.player.maxJumps = 2;
  this.player.jumps = 0;
  this.player.canDash = true;

  // Physics collisions
  this.physics.add.collider(this.player, platforms, (p) => {
    if (p.body.velocity.y > 0) {
      p.jumps = 0; // reset double jump
      p.canDash = true;
    }
  });

  // Enemies group (patrolling)
  this.enemies = this.physics.add.group();
  for (let i=0;i<10;i++){
    const ex = 500 + i*240;
    const ey = GAME_HEIGHT - 130 - (i%3)*36;
    const e = this.enemies.create(ex, ey, 'enemy');
    e.setCollideWorldBounds(true);
    e.setVelocityX( (i%2?40:-40) );
    e.setBounceX(1);
  }
  this.physics.add.collider(this.enemies, platforms);
  this.physics.add.overlap(this.player, this.enemies, this.onPlayerHitEnemy, null, this);

  // Collectibles
  this.orbs = this.physics.add.group();
  for (let i=0;i<20;i++){
    const ox = 220 + i*160 + (i%3)*26;
    const oy = GAME_HEIGHT - 200 - (i%4)*40;
    const orb = this.orbs.create(ox, oy, 'orb');
    orb.setBounceY(Phaser.Math.FloatBetween(0.2, 0.8));
  }
  this.physics.add.overlap(this.player, this.orbs, this.collectOrb, null, this);

  // Particle emitter for jumps/collects
  this.particles = this.add.particles('spark');
  this.collectEmitter = this.particles.createEmitter({
    speed: { min: -120, max: 120 },
    lifespan: 500,
    quantity: 8,
    scale: { start: 0.9, end: 0 },
    on: false
  });

  // Camera follow player
  this.cameras.main.startFollow(this.player, true, 0.12, 0.12, -160, 0);
  this.cameras.main.setZoom(1.05);

  // HUD via UI Scene (separate layer)
  this.scene.launch('UIScene', { level: this.levelIndex });

  // Controls
  this.keys = this.input.keyboard.addKeys({
    left: Phaser.Input.Keyboard.KeyCodes.LEFT,
    right: Phaser.Input.Keyboard.KeyCodes.RIGHT,
    up: Phaser.Input.Keyboard.KeyCodes.UP,
    z: Phaser.Input.Keyboard.KeyCodes.Z,
    x: Phaser.Input.Keyboard.KeyCodes.X,
    space: Phaser.Input.Keyboard.KeyCodes.SPACE
  });

  // Sound placeholders (simple beep using Oscillator via WebAudio)
  try {
    this.audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  } catch(e) { this.audioCtx = null; }

  // level end portal (simple flag)
  this.flag = this.physics.add.sprite(levelWidth - 160, GAME_HEIGHT - 200, 'player').setTint(0xffd36b).setScale(0.8);
  this.flag.body.setAllowGravity(false);
  this.physics.add.overlap(this.player, this.flag, ()=> {
    this.cameras.main.flash(400,255,255,255);
    this.scene.stop('UIScene');
    this.scene.start('OverworldScene');
  }, null, this);

  // small fx when landing
  this.lastOnGround = false;

  // polish: small music-like repeating tone (optional)
  this.muted = false;
  this.soundOn = true;
  this.input.keyboard.on('keydown-M', ()=> { this.soundOn = !this.soundOn; });

  // Smoothing: add dust on land
  this.landParticles = this.particles.createEmitter({
    x:0,y:0,
    speedY: { min: -20, max: -80 },
    speedX: { min: -40, max: 40 },
    lifespan: 500,
    quantity: 6,
    scale: { start: 0.6, end: 0.0 },
    on: false
  });
};

LevelScene.prototype.collectOrb = function(player, orb) {
  orb.disableBody(true,true);
  this.collectEmitter.setPosition(orb.x, orb.y);
  this.collectEmitter.explode(12);
  // small sound
  if (this.audioCtx && this.soundOn) playTone(this.audioCtx, 760, 0.07);
  // update UI
  const ui = this.scene.get('UIScene');
  if (ui && ui.updateScore) ui.updateScore(1);
};

LevelScene.prototype.onPlayerHitEnemy = function(player, enemy) {
  // simple bounce or respawn mechanic
  if (player.body.velocity.y > 150) {
    // jump stomp kill
    enemy.disableBody(true,true);
    this.particles.createEmitter({
      x: enemy.x, y: enemy.y,
      lifespan: 400, quantity: 12, speed: { min:-200, max:200 }, scale: { start: 1.0, end:0 }, on: false
    }).explode(12, enemy.x, enemy.y);
    player.setVelocityY(-420);
    if (this.audioCtx && this.soundOn) playTone(this.audioCtx, 480, 0.06);
  } else {
    // knockback and respawn to start
    this.cameras.main.shake(260,0.01);
    player.setTint(0xff6b6b);
    player.disableBody(true,true);
    this.time.delayedCall(600, ()=> {
      player.enableBody(true, this.startX, GAME_HEIGHT - 200, true, true);
      player.clearTint();
    });
    if (this.audioCtx && this.soundOn) playTone(this.audioCtx, 200, 0.12);
  }
};

LevelScene.prototype.update = function(time, dt) {
  const left = this.keys.left.isDown;
  const right = this.keys.right.isDown;
  const jumpPress = Phaser.Input.Keyboard.JustDown(this.keys.z) || Phaser.Input.Keyboard.JustDown(this.keys.space);
  const dashPress = Phaser.Input.Keyboard.JustDown(this.keys.x);

  // horizontal movement
  if (left) {
    this.player.setVelocityX(-220);
    this.player.flipX = true;
  } else if (right) {
    this.player.setVelocityX(220);
    this.player.flipX = false;
  } else {
    this.player.setVelocityX(0);
  }

  // ground check
  const onGround = this.player.body.blocked.down || this.player.body.touching.down;

  // landed
  if (onGround && !this.lastOnGround) {
    this.landParticles.setPosition(this.player.x, this.player.y + 24);
    this.landParticles.explode(10);
    if (this.audioCtx && this.soundOn) playTone(this.audioCtx, 280, 0.06);
  }
  this.lastOnGround = onGround;

  // jumping / double jump
  if (jumpPress) {
    if (onGround || this.player.jumps < this.player.maxJumps) {
      this.player.setVelocityY(-460);
      this.player.jumps++;
      // little particle
      this.particles.createEmitter({
        x: this.player.x, y: this.player.y + 20, speed: { min:-80, max:80 }, lifespan: 300, quantity: 8, scale:{start:0.6,end:0}, on: false
      }).explode(8, this.player.x, this.player.y+14);
      if (this.audioCtx && this.soundOn) playTone(this.audioCtx, 640, 0.06);
    }
  }

  // dash
  if (dashPress && this.player.canDash) {
    const dir = this.player.flipX ? -1 : 1;
    this.player.setVelocityX(700 * dir);
    this.player.canDash = false;
    this.time.delayedCall(120, ()=> {
      // reduce velocity after dash
      if (this.player) this.player.setVelocityX( (dir>0)?260:-260 );
    });
    if (this.audioCtx && this.soundOn) playTone(this.audioCtx, 920, 0.05);
  }

  // small animation: tilt player when moving
  this.player.angle = Phaser.Math.Clamp(this.player.body.velocity.x / 10, -8, 8);

  // parallax tile movement
  this.children.list.filter(c=>c.tilePositionX!==undefined).forEach(layer=>{
    layer.tilePositionX = this.cameras.main.scrollX * layer.scrollFactorX;
  });
};

/* ----------------- UI Scene ---------------- */
function UIScene() { Phaser.Scene.call(this, { key: 'UIScene', active: false }); }
UIScene.prototype = Object.create(Phaser.Scene.prototype);
UIScene.prototype.constructor = UIScene;
UIScene.prototype.init = function(data) {
  this.level = data.level || 1;
};
UIScene.prototype.create = function() {
  // score text & lives
  this.score = 0;
  this.scoreText = this.add.text(18, 12, `Score: ${this.score}`, { font: '20px Arial', fill:'#eaffff' }).setScrollFactor(0).setDepth(99);

  // level label
  this.levelText = this.add.text(GAME_WIDTH/2, 12, `Level ${this.level}`, { font: '20px Arial', fill:'#f6f7ff' }).setOrigin(0.5).setScrollFactor(0);

  // pause button (clickable)
  const pauseBtn = this.add.text(GAME_WIDTH - 18, 12, '❚❚', { font: '20px Arial', fill:'#bcd' }).setOrigin(1,0).setInteractive({useHandCursor:true}).setScrollFactor(0);
  pauseBtn.on('pointerdown', ()=> {
    if (this.scene.isPaused('LevelScene')) {
      this.scene.resume('LevelScene');
      pauseBtn.setText('❚❚');
    } else {
      this.scene.pause('LevelScene');
      pauseBtn.setText('▶');
    }
  });

  // small instruction text
  this.add.text(18, GAME_HEIGHT - 28, 'Z jump • X dash', { font: '13px Arial', fill:'#bcd' }).setScrollFactor(0);

  // method to let LevelScene update score
  this.updateScore = (v) => {
    this.score += v;
    this.scoreText.setText(`Score: ${this.score}`);
    // small pop animation
    this.tweens.add({ targets: this.scoreText, scale: 1.12, yoyo:true, duration:180, ease:'Power1' });
  };
};

/* ----------------- Utility: simple WebAudio beep ----------------- */
function playTone(ctx, freq=440, length=0.08) {
  try {
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = 'sine';
    o.frequency.value = freq;
    o.connect(g);
    g.connect(ctx.destination);
    g.gain.setValueAtTime(0.0001, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.15, ctx.currentTime + 0.01);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + length);
    o.stop(ctx.currentTime + length + 0.02);
  } catch(e) { /* ignore */ }
}

/* ----------------- Boot: register scenes and launch ----------------- */
const game = new Phaser.Game(config);

/* attach scene constructors to global so config creation above can reference them */
function registerScenes() {
  // already declared above; Phaser created instances from keys
}
</script>
</body>
</html>
