<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ToonyTime Platformer — Fixed</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; background:#0b1020; color:#eaeef6; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
    #gameContainer { width:100%; height:100vh; display:flex; align-items:center; justify-content:center; }
    canvas { image-rendering: pixelated; }
    .note {
      position:fixed; left:12px; bottom:10px; font-size:13px; opacity:.85;
      background:linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
      padding:6px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.03);
      backdrop-filter: blur(4px);
    }
  </style>
  <!-- Phaser CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
  <div id="gameContainer"></div>
  <div class="note">Arrows / A D to move, Z or Space to jump, X to dash, M mute</div>

<script>
/* -------------------------
   Fixed ToonyTime Platformer
   Single-file HTML
   ------------------------- */

const GAME_WIDTH = 960;
const GAME_HEIGHT = 540;

/* ========== Scenes (defined BEFORE creating the game) ========== */

/* ------------------- BootScene ------------------- */
class BootScene extends Phaser.Scene {
  constructor() { super({ key: 'BootScene' }); }
  preload() {
    // no external assets; generate textures in create()
  }
  create() {
    // Generate simple runtime textures (player, enemy, tile, orb, cloud, spark)
    const make = (name, drawFn, w, h) => {
      const g = this.make.graphics({ add: false });
      drawFn(g);
      g.generateTexture(name, w, h);
      g.destroy();
    };

    // Player (rounded rectangle)
    make('player', g => {
      g.fillStyle(0x58a6ff, 1);
      g.fillRoundedRect(0,0,40,48,8);
      g.fillStyle(0x11334a, 1);
      g.fillRect(10,30,20,6);
    }, 40,48);

    // Enemy (rounded)
    make('enemy', g => {
      g.fillStyle(0xff7b7b, 1);
      g.fillRoundedRect(0,0,36,34,8);
      g.fillStyle(0x2b0b0b,1);
      g.fillRect(8,22,20,4);
    }, 36,34);

    // Orb collectible
    make('orb', g => {
      g.fillStyle(0xfff372,1);
      g.fillCircle(12,12,12);
      g.fillStyle(0xffffff,0.5);
      g.fillCircle(8,8,4);
    }, 24,24);

    // Tile platform
    make('tile', g => {
      g.fillStyle(0x3b5b6e, 1);
      g.fillRect(0,0,64,24);
      g.fillStyle(0x23414f,1);
      g.fillRect(0,0,64,6);
    }, 64,24);

    // Cloud (soft)
    make('cloud', g => {
      g.fillStyle(0xffffff, 0.12);
      g.fillEllipse(80,40,160,80);
      g.fillEllipse(20,60,120,60);
    }, 160,120);

    // Spark particle
    make('spark', g => {
      g.fillStyle(0xffffff, 1);
      g.fillCircle(4,4,4);
    }, 8,8);

    this.scene.start('MenuScene');
  }
}

/* ------------------- MenuScene ------------------- */
class MenuScene extends Phaser.Scene {
  constructor(){ super({ key: 'MenuScene' }); }
  create() {
    // background
    const bg = this.add.rectangle(0,0,GAME_WIDTH,GAME_HEIGHT,0x061025).setOrigin(0);
    // title
    this.add.text(GAME_WIDTH/2, 110, 'TOONYTIME', { font: '64px Arial', fill: '#eaf6ff' }).setOrigin(0.5).setShadow(2,2,'#000',8);

    // Play button
    const play = this.add.rectangle(GAME_WIDTH/2, 250, 360, 72, 0x4477aa).setStrokeStyle(2,0xffffff,0.06).setInteractive({ useHandCursor:true });
    const playText = this.add.text(GAME_WIDTH/2, 250, 'Play — Overworld', { font: '28px Arial', fill:'#fff' }).setOrigin(0.5);
    play.on('pointerdown', () => {
      this.cameras.main.flash(180,255,255,255);
      this.scene.start('OverworldScene');
    });

    // Quick Level
    const quick = this.add.rectangle(GAME_WIDTH/2, 340, 240, 52, 0x66aa66).setInteractive({ useHandCursor:true });
    const qText = this.add.text(GAME_WIDTH/2, 340, 'Quick Level', { font: '20px Arial', fill:'#072' }).setOrigin(0.5);
    quick.on('pointerdown', () => this.scene.start('LevelScene', { level:1, startX: 120 }));

    // Particles
    this.add.particles('spark').createEmitter({
      x: { min: 0, max: GAME_WIDTH }, y: GAME_HEIGHT - 130, lifespan: 3000, speedY: { min:-80, max:-160 }, quantity: 1, scale: { start:1, end:0 }, frequency: 220
    });

    // Note
    this.add.text(14, GAME_HEIGHT - 18, 'Demo — no external assets', { font: '12px Arial', fill:'#bcd' });
  }
}

/* ------------------- OverworldScene ------------------- */
class OverworldScene extends Phaser.Scene {
  constructor(){ super({ key: 'OverworldScene' }); }
  create() {
    const mapWidth = 2200;
    this.cameras.main.setBounds(0,0,mapWidth,GAME_HEIGHT);
    this.physics.world.setBounds(0,0,mapWidth,GAME_HEIGHT);
    this.cameras.main.setBackgroundColor('#081125');

    // clouds (parallax)
    for (let i=0;i<6;i++){
      const c = this.add.image(120 + i*300, 80 + (i%2)*22, 'cloud').setAlpha(0.1 + 0.02*i).setScale(0.8 + (i%3)*0.18);
      c.setScrollFactor(0.3 + (i%2)*0.05);
    }

    // ground strip
    this.add.rectangle(0, GAME_HEIGHT - 110, mapWidth, 110, 0x123b3f).setOrigin(0);

    // nodes
    this.nodes = [];
    const nodeCount = 6;
    for (let i=0;i<nodeCount;i++){
      const x = 120 + i*((mapWidth-240)/(nodeCount-1));
      const y = GAME_HEIGHT - 170 - Math.sin(i*1.2)*60;
      const node = this.add.circle(x,y,26,0x7ad6ff).setStrokeStyle(3,0xffffff,0.12).setInteractive({ useHandCursor:true });
      const label = this.add.text(x,y+46, `Level ${i+1}`, { font: '18px Arial', fill:'#dff' }).setOrigin(0.5);
      node.levelIndex = i+1;
      node.on('pointerdown', ()=> this.scene.start('LevelScene', { level: node.levelIndex, startX: x }));
      this.nodes.push(node);
    }

    // simple cursor icon (created as small triangle graphic texture)
    const g = this.make.graphics({ add: false });
    g.fillStyle(0x8effa2, 1);
    g.fillTriangle(0,32, 12,0, 24,32);
    g.generateTexture('cursorIcon', 24, 32);
    g.destroy();
    this.cursor = this.add.image(this.nodes[0].x, this.nodes[0].y-60, 'cursorIcon');
    this.cursor.setDepth(10);

    // camera follow
    this.cameras.main.startFollow(this.cursor, true, 0.08, 0.08);

    // interaction
    this.input.on('pointerdown', (p)=> { this.dragging = true; this.lastPointerX = p.x; });
    this.input.on('pointerup', ()=> { this.dragging = false; });

    // keyboard
    this.keys = this.input.keyboard.addKeys({ left:Phaser.Input.Keyboard.KeyCodes.LEFT, right:Phaser.Input.Keyboard.KeyCodes.RIGHT });

    // floating tween
    this.tweens.add({ targets: this.cursor, y: `-=${18}`, duration: 1200, yoyo:true, repeat:-1, ease:'Sine.easeInOut' });

    this.add.text(18,18,'Overworld — select a level', { font: '18px Arial', fill:'#dff' }).setScrollFactor(0);
  }
  update() {
    if (this.dragging && this.input.activePointer.isDown) {
      const dx = (this.lastPointerX - this.input.activePointer.x);
      this.lastPointerX = this.input.activePointer.x;
      this.cursor.x += dx;
    } else {
      if (this.keys.left.isDown) this.cursor.x -= 4;
      if (this.keys.right.isDown) this.cursor.x += 4;
    }
    this.cursor.x = Phaser.Math.Clamp(this.cursor.x, 40, 2160);

    // snap vertically toward nearest node
    let nearest = null;
    let best = 1e9;
    for (const n of this.nodes) {
      const d = Math.abs(n.x - this.cursor.x);
      if (d < best) { best = d; nearest = n; }
    }
    if (nearest) {
      this.cursor.y = Phaser.Math.Linear(this.cursor.y, nearest.y - 60, 0.06);
    }
  }
}

/* ------------------- LevelScene ------------------- */
class LevelScene extends Phaser.Scene {
  constructor(){ super({ key: 'LevelScene' }); }
  init(data){ this.levelIndex = data.level || 1; this.startX = data.startX || 120; }
  create() {
    // level size
    this.levelWidth = 3200;
    this.cameras.main.setBounds(0,0,this.levelWidth,GAME_HEIGHT);
    this.physics.world.setBounds(0,0,this.levelWidth,GAME_HEIGHT);

    // background tilesprites for parallax (keep references)
    this.farClouds = this.add.tileSprite(0,40,this.levelWidth,120,'cloud').setOrigin(0).setAlpha(0.09).setScrollFactor(0);
    this.cloudLayer = this.add.tileSprite(0,80,this.levelWidth,120,'cloud').setOrigin(0).setAlpha(0.14).setScrollFactor(0);
    this.mountains = this.add.tileSprite(0,GAME_HEIGHT - 260,this.levelWidth,200,'cloud').setOrigin(0).setAlpha(0.08).setScrollFactor(0);

    // create platforms (static group)
    this.platforms = this.physics.add.staticGroup();
    // ground strips
    for (let i=0;i<60;i++){
      const x = i*64;
      const y = GAME_HEIGHT - 64;
      this.platforms.create(x, y, 'tile').setOrigin(0).refreshBody();
    }
    // floating platforms
    for (let i=0;i<20;i++){
      const x = 300 + i*160;
      const y = GAME_HEIGHT - 220 - ((i%4)*35);
      const p = this.platforms.create(x,y,'tile').setOrigin(0).refreshBody();
      this.tweens.add({ targets: p, y: p.y+6, yoyo:true, repeat:-1, duration:2000 + i*30 });
    }

    // player
    this.player = this.physics.add.sprite(this.startX, GAME_HEIGHT - 200, 'player').setCollideWorldBounds(true).setDepth(5);
    this.player.body.setSize(30,44).setOffset(5,2);
    this.player.maxJumps = 2;
    this.player.jumps = 0;
    this.player.canDash = true;

    // collisions
    this.physics.add.collider(this.player, this.platforms, () => {
      if (this.player.body.velocity.y >= 0) { this.player.jumps = 0; this.player.canDash = true; }
    });

    // enemies
    this.enemies = this.physics.add.group();
    for (let i=0;i<10;i++){
      const ex = 500 + i*240;
      const ey = GAME_HEIGHT - 130 - (i%3)*36;
      const e = this.enemies.create(ex, ey, 'enemy');
      e.setCollideWorldBounds(true);
      e.setVelocityX((i%2?40:-40));
      e.setBounceX(1);
    }
    this.physics.add.collider(this.enemies, this.platforms);
    this.physics.add.overlap(this.player, this.enemies, this.onPlayerHitEnemy, null, this);

    // orbs
    this.orbs = this.physics.add.group();
    for (let i=0;i<20;i++){
      const ox = 220 + i*160 + (i%3)*26;
      const oy = GAME_HEIGHT - 200 - (i%4)*40;
      const orb = this.orbs.create(ox, oy, 'orb');
      orb.setBounceY(Phaser.Math.FloatBetween(0.2, 0.8));
    }
    this.physics.add.overlap(this.player, this.orbs, this.collectOrb, null, this);

    // particles
    this.particles = this.add.particles('spark');
    this.collectEmitter = this.particles.createEmitter({ speed:{min:-120,max:120}, lifespan:500, quantity:8, scale:{start:0.9,end:0}, on:false });
    this.landEmitter = this.particles.createEmitter({ speedY:{min:-20,max:-80}, speedX:{min:-40,max:40}, lifespan:500, quantity:6, scale:{start:0.6,end:0}, on:false });

    // camera
    this.cameras.main.startFollow(this.player, true, 0.12, 0.12, -160, 0);
    this.cameras.main.setZoom(1.05);

    // HUD
    this.scene.launch('UIScene', { level: this.levelIndex });

    // controls (include A/D)
    this.keys = this.input.keyboard.addKeys({
      left: Phaser.Input.Keyboard.KeyCodes.LEFT,
      right: Phaser.Input.Keyboard.KeyCodes.RIGHT,
      a: Phaser.Input.Keyboard.KeyCodes.A,
      d: Phaser.Input.Keyboard.KeyCodes.D,
      z: Phaser.Input.Keyboard.KeyCodes.Z,
      space: Phaser.Input.Keyboard.KeyCodes.SPACE,
      x: Phaser.Input.Keyboard.KeyCodes.X
    });

    // audio context for tiny beeps
    try { this.audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e){ this.audioCtx = null; }
    this.soundOn = true;
    this.input.keyboard.on('keydown-M', ()=> this.soundOn = !this.soundOn);

    // level flag - finish
    this.flag = this.physics.add.sprite(this.levelWidth - 160, GAME_HEIGHT - 200, 'player').setTint(0xffd36b).setScale(0.8);
    this.flag.body.setAllowGravity(false);
    this.physics.add.overlap(this.player, this.flag, ()=> {
      this.cameras.main.flash(400,255,255,255);
      this.scene.stop('UIScene');
      this.scene.start('OverworldScene');
    });

    this.lastOnGround = false;
  }

  collectOrb(player, orb) {
    orb.disableBody(true,true);
    this.collectEmitter.explode(12, orb.x, orb.y);
    if (this.audioCtx && this.soundOn) playTone(this.audioCtx, 760, 0.07);
    const ui = this.scene.get('UIScene');
    if (ui && ui.updateScore) ui.updateScore(1);
  }

  onPlayerHitEnemy(player, enemy) {
    // if player is falling fast, stomp
    if (player.body.velocity.y > 150) {
      enemy.disableBody(true,true);
      this.particles.createEmitter({ x: enemy.x, y: enemy.y, lifespan:400, quantity:12, speed:{min:-200,max:200}, scale:{start:1,end:0}, on:false }).explode(12, enemy.x, enemy.y);
      player.setVelocityY(-420);
      if (this.audioCtx && this.soundOn) playTone(this.audioCtx, 480, 0.06);
      return;
    }
    // else take damage / respawn
    this.cameras.main.shake(260,0.01);
    player.setTint(0xff6b6b);
    player.disableBody(true,true);
    if (this.audioCtx && this.soundOn) playTone(this.audioCtx, 200, 0.12);
    this.time.delayedCall(600, ()=> {
      player.enableBody(true, this.startX, GAME_HEIGHT - 200, true, true);
      player.clearTint();
    });
  }

  update() {
    const left = this.keys.left.isDown || this.keys.a.isDown;
    const right = this.keys.right.isDown || this.keys.d.isDown;
    const jumpPress = Phaser.Input.Keyboard.JustDown(this.keys.z) || Phaser.Input.Keyboard.JustDown(this.keys.space);
    const dashPress = Phaser.Input.Keyboard.JustDown(this.keys.x);

    // movement
    if (left) {
      this.player.setVelocityX(-220);
      this.player.flipX = true;
    } else if (right) {
      this.player.setVelocityX(220);
      this.player.flipX = false;
    } else {
      // small friction
      this.player.setVelocityX( this.player.body.onFloor() ? 0 : this.player.body.velocity.x * 0.98 );
    }

    const onGround = this.player.body.blocked.down || this.player.body.touching.down;
    if (onGround && !this.lastOnGround) {
      this.landEmitter.explode(10, this.player.x, this.player.y + 24);
      if (this.audioCtx && this.soundOn) playTone(this.audioCtx, 280, 0.06);
    }
    this.lastOnGround = onGround;

    // jump & double jump
    if (jumpPress) {
      if (onGround || this.player.jumps < this.player.maxJumps) {
        this.player.setVelocityY(-460);
        this.player.jumps++;
        this.particles.createEmitter({ x:this.player.x, y:this.player.y+20, speed:{min:-80,max:80}, lifespan:300, quantity:8, scale:{start:0.6,end:0}, on:false }).explode(8, this.player.x, this.player.y+14);
        if (this.audioCtx && this.soundOn) playTone(this.audioCtx, 640, 0.06);
      }
    }

    // dash
    if (dashPress && this.player.canDash) {
      const dir = this.player.flipX ? -1 : 1;
      this.player.setVelocityX(700 * dir);
      this.player.canDash = false;
      this.time.delayedCall(120, ()=> { if (this.player) this.player.setVelocityX((dir>0)?260:-260); });
      if (this.audioCtx && this.soundOn) playTone(this.audioCtx, 920, 0.05);
    }

    // tilt for style
    this.player.angle = Phaser.Math.Clamp(this.player.body.velocity.x / 10, -8, 8);

    // update parallax tilePositions using camera scroll
    const sX = this.cameras.main.scrollX;
    this.farClouds.tilePositionX = sX * 0.2;
    this.cloudLayer.tilePositionX = sX * 0.35;
    this.mountains.tilePositionX = sX * 0.12;
  }
}

/* ------------------- UIScene ------------------- */
class UIScene extends Phaser.Scene {
  constructor(){ super({ key: 'UIScene' }); }
  init(data){ this.level = data.level || 1; }
  create() {
    this.score = 0;
    this.scoreText = this.add.text(18,12, `Score: ${this.score}`, { font: '20px Arial', fill:'#eaffff' }).setScrollFactor(0).setDepth(99);
    this.levelText = this.add.text(GAME_WIDTH/2, 12, `Level ${this.level}`, { font: '20px Arial', fill:'#f6f7ff' }).setOrigin(0.5).setScrollFactor(0);
    const pauseBtn = this.add.text(GAME_WIDTH - 18, 12, '❚❚', { font: '20px Arial', fill:'#bcd' }).setOrigin(1,0).setInteractive({ useHandCursor:true }).setScrollFactor(0);
    pauseBtn.on('pointerdown', ()=> {
      if (this.scene.isPaused('LevelScene')) { this.scene.resume('LevelScene'); pauseBtn.setText('❚❚'); }
      else { this.scene.pause('LevelScene'); pauseBtn.setText('▶'); }
    });
    this.add.text(18, GAME_HEIGHT - 28, 'Z / Space jump • X dash', { font: '13px Arial', fill:'#bcd' }).setScrollFactor(0);
  }
  updateScore(v) {
    this.score += v;
    this.scoreText.setText(`Score: ${this.score}`);
    this.tweens.add({ targets: this.scoreText, scale:1.12, yoyo:true, duration:180 });
  }
}

/* ========== Utility: simple WebAudio beep ========== */
function playTone(ctx, freq=440, length=0.08) {
  try {
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = 'sine';
    o.frequency.value = freq;
    o.connect(g);
    g.connect(ctx.destination);
    g.gain.setValueAtTime(0.0001, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.15, ctx.currentTime + 0.01);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + length);
    o.stop(ctx.currentTime + length + 0.02);
  } catch(e) { /* ignore */ }
}

/* ========== Create game ========== */
const config = {
  type: Phaser.AUTO,
  parent: 'gameContainer',
  width: GAME_WIDTH,
  height: GAME_HEIGHT,
  backgroundColor: '#0b1220',
  physics: { default: 'arcade', arcade: { gravity: { y: 1200 }, debug: false } },
  scene: [ BootScene, MenuScene, OverworldScene, LevelScene, UIScene ]
};

const game = new Phaser.Game(config);

</script>
</body>
</html>
